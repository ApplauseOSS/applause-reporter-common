{"version":3,"file":"index.min.js","sources":["../src/auto-api/version.ts","../src/auto-api/auto-api-config.ts","../src/shared/logging.ts","../src/auto-api/auto-api.ts","../src/auto-api/dto.ts","../src/auto-api/email/inbox.ts","../src/auto-api/heartbeat.ts","../src/shared/test-case.ts","../src/auto-api/reporter.ts","../src/public-api/dto.ts","../src/public-api/public-api-config.ts","../src/config/config.ts","../src/auto-api/email-helper.ts","../src/public-api/public-api.ts"],"sourcesContent":["export const API_VERSION = '1.1.0';\n","import { TestRailOptions } from './dto.ts';\nimport Validator from 'validator';\nconst validator = Validator.default;\n\nexport interface AutoApiConfig {\n  readonly autoApiBaseUrl: string;\n  readonly apiKey: string;\n  readonly productId: number;\n  readonly testRailOptions?: TestRailOptions;\n  readonly applauseTestCycleId?: number;\n  readonly timeout?: number;\n}\n\nexport const DEFAULT_URL = 'https://prod-auto-api.cloud.applause.com/';\n\nexport const DEFAULT_AUTO_API_PROPERTIES: Partial<AutoApiConfig> = {\n  autoApiBaseUrl: DEFAULT_URL,\n};\n\nexport function isAutoApiConfigComplete(\n  config: Partial<AutoApiConfig>\n): boolean {\n  return (\n    config.autoApiBaseUrl !== undefined &&\n    config.apiKey !== undefined &&\n    config.productId !== undefined\n  );\n}\n\nexport function validatePartialAutoApiConfig(config: Partial<AutoApiConfig>) {\n  if (\n    config.productId !== undefined &&\n    (!Number.isInteger(config.productId) || config.productId <= 0)\n  ) {\n    throw new Error(\n      `productId must be a positive integer, was: '${config.productId}'`\n    );\n  }\n}\n\nexport function validateAutoApiConfig(config: AutoApiConfig) {\n  if (!Number.isInteger(config.productId) || config.productId <= 0) {\n    throw new Error(\n      `productId must be a positive integer, was: '${config.productId}'`\n    );\n  }\n  if (\n    !validator.isURL(config.autoApiBaseUrl, {\n      protocols: ['http', 'https'],\n      require_tld: false, // allow localhost\n      allow_query_components: false,\n      disallow_auth: true,\n      allow_fragments: false,\n      allow_protocol_relative_urls: false,\n      allow_trailing_dot: false,\n      require_host: true,\n      require_protocol: true,\n    })\n  ) {\n    throw new Error(\n      `autoApiBaseUrl is not valid HTTP/HTTPS URL, was: ${config.autoApiBaseUrl}`\n    );\n  }\n\n  if (validator.isEmpty(config.apiKey)) {\n    throw new Error('apiKey is an empty string!');\n  }\n}\n","import * as winston from 'winston';\nimport { TransformableInfo } from 'logform';\nimport TransportStream from 'winston-transport';\nconst MESSAGE = Symbol.for('message');\n\nexport const WINSTON_DEFAULT_LOG_FORMAT = winston.format.printf(\n  ({ level, message, label, timestamp }) => {\n    return `${timestamp} [${label}] ${level}: ${message}`;\n  }\n);\n\nexport function constructDefaultLogger(): winston.Logger {\n  return winston.createLogger({\n    format: winston.format.combine(\n      winston.format.label({ label: 'Applause Tests' }),\n      winston.format.timestamp(),\n      winston.format.splat(),\n      WINSTON_DEFAULT_LOG_FORMAT\n    ),\n    transports: [\n      new winston.transports.File({ filename: 'error.log', level: 'error' }),\n      new winston.transports.File({ filename: 'combined.log' }),\n      new ApplauseTransport(),\n      new winston.transports.Console({\n        level: 'info',\n        format: winston.format.combine(\n          winston.format.colorize(),\n          WINSTON_DEFAULT_LOG_FORMAT\n        ),\n      }),\n    ],\n  });\n}\n\n/**\n * A simple Class for storing and retrieving log messages.\n */\nexport class LoggingContainer {\n  private logs: string[] = [];\n\n  /**\n   * Retrieves all logs stored in the container.\n   *\n   * @returns An array of log messages.\n   */\n  public getLogs(): string[] {\n    return this.logs;\n  }\n\n  /**\n   * Retrieves and clears all logs stored in the container.\n   *\n   * @returns An array of log messages.\n   */\n  public drainLogs(): string[] {\n    const logs = this.logs;\n    this.clearLogs();\n    return logs;\n  }\n\n  /**\n   * Clears all logs stored in the container.\n   */\n  public clearLogs(): void {\n    this.logs = [];\n  }\n\n  /**\n   * Adds a log message to the container.\n   *\n   * @param log - The log message to add.\n   */\n  public addLog(log: string): void {\n    this.logs.push(log);\n  }\n}\n\n// Create a new Shared LoggingContainer to store logs\nexport const APPLAUSE_LOG_RECORDS: LoggingContainer = new LoggingContainer();\n\n/**\n * A Custom Winston Transport that sends logs to the Applause LoggingContainer\n */\nexport class ApplauseTransport extends TransportStream {\n  constructor(opts?: TransportStream.TransportStreamOptions) {\n    super(opts);\n  }\n\n  log(info: TransformableInfo, callback: () => void): void {\n    setImmediate(() => {\n      this.emit('logged', info);\n    });\n\n    this.format?.transform(info);\n    APPLAUSE_LOG_RECORDS.addLog(\n      (info[MESSAGE] as string | undefined) ?? (info.message as string)\n    );\n\n    // Continue to the next transport\n    callback();\n  }\n}\n","/**\n * This file contains the implementation of the `AutoApi` class, which is responsible for making API calls to interact with the Applause platform.\n * The `AutoApi` class provides methods for starting and ending test runs, creating test cases, submitting test case results, and performing other operations related to test management.\n * It also includes properties and methods to track the number of HTTP calls in progress.\n */\n\nimport axios, { AxiosError, AxiosInstance, AxiosResponse } from 'axios';\nimport {\n  AssetType,\n  CreateTestCaseResultDto,\n  CreateTestCaseResultResponseDto,\n  EmailAddressResponse,\n  EmailFetchRequest,\n  SubmitTestCaseResultDto,\n  TestResultProviderInfo,\n  TestRunCreateDto,\n  TestRunCreateResponseDto,\n} from './dto.ts';\nimport { API_VERSION } from './version.ts';\nimport { AutoApiConfig, validateAutoApiConfig } from './auto-api-config.ts';\nimport { constructDefaultLogger } from '../shared/logging.ts';\nimport * as winston from 'winston';\n\nexport class AutoApi {\n  private readonly client: AxiosInstance;\n\n  private logger: winston.Logger;\n  private callsInFlight: number;\n  /**\n   * Tracks the number of HTTP calls in progress.\n   * This property is used by reporters that want to know when the async work is finished.\n   */\n  public get getCallsInFlight(): number {\n    return this.callsInFlight;\n  }\n\n  /**\n   * Creates an instance of the `AutoApi` class.\n   * @param options - The configuration options for the Applause API.\n   */\n  constructor(\n    readonly options: AutoApiConfig,\n    logger?: winston.Logger\n  ) {\n    this.callsInFlight = 0;\n    this.logger = logger ?? constructDefaultLogger();\n    validateAutoApiConfig(options);\n    this.client = axios.create({\n      baseURL: options.autoApiBaseUrl,\n      timeout: options.timeout ?? 300_000,\n      headers: {\n        'X-Api-Key': options.apiKey,\n        'Context-Type': 'application/json',\n      },\n      responseType: 'json',\n    });\n\n    this.client.interceptors.response.use(\n      function (response: AxiosResponse<unknown, unknown>) {\n        return response;\n      },\n      (error: AxiosError) => {\n        // log and rethrow\n        const errText =\n           \n          error.response?.data !== undefined\n            ? JSON.stringify(error.response.data)\n            : `error-code [${error.response?.status}] with error [${error.response?.statusText}]`;\n        this.logger.error(`Auto-Api returned ${errText}`);\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  /**\n   * Starts a new test run.\n   * @param info - The information for creating the test run.\n   * @returns A promise that resolves to the response containing the created test run.\n   */\n  async startTestRun(\n    info: TestRunCreateDto\n  ): Promise<AxiosResponse<TestRunCreateResponseDto>> {\n    this.callsInFlight += 1;\n    try {\n      return await this.client.post<TestRunCreateResponseDto>(\n        '/api/v1.0/test-run/create',\n        {\n          // Provided params\n          ...info,\n\n          // API Version\n          sdkVersion: `js:${API_VERSION}`,\n\n          // Copy over the product id\n          productId: this.options.productId,\n\n          itwTestCycleId: this.options.applauseTestCycleId,\n\n          // Copy over test rail parameters\n          testRailReportingEnabled: this.options.testRailOptions !== undefined,\n          addAllTestsToPlan: this.options.testRailOptions?.addAllTestsToPlan,\n          testRailProjectId: this.options.testRailOptions?.projectId,\n          testRailSuiteId: this.options.testRailOptions?.suiteId,\n          testRailPlanName: this.options.testRailOptions?.planName,\n          testRailRunName: this.options.testRailOptions?.runName,\n          overrideTestRailRunNameUniqueness:\n            this.options.testRailOptions?.overrideTestRailRunUniqueness,\n        }\n      );\n    } finally {\n      this.callsInFlight -= 1;\n    }\n  }\n\n  /**\n   * Ends a test run.\n   * @param testRunId - The ID of the test run to end.\n   * @returns A promise that resolves to the response indicating the completion of the test run.\n   */\n  async endTestRun(testRunId: number): Promise<AxiosResponse<void>> {\n    this.callsInFlight += 1;\n    try {\n      return await this.client.delete<void>(\n        `/api/v1.0/test-run/${testRunId}?endingStatus=COMPLETE`\n      );\n    } finally {\n      this.callsInFlight -= 1;\n    }\n  }\n\n  /**\n   * Starts a new test case.\n   * @param params - The parameters for creating the test case.\n   * @returns A promise that resolves to the response containing the created test case.\n   */\n  async startTestCase(\n    params: CreateTestCaseResultDto\n  ): Promise<AxiosResponse<CreateTestCaseResultResponseDto>> {\n    this.callsInFlight += 1;\n    try {\n      const res = await this.client.post<CreateTestCaseResultResponseDto>(\n        '/api/v1.0/test-result/create-result',\n        params\n      );\n      return res;\n    } finally {\n      this.callsInFlight -= 1;\n    }\n  }\n\n  /**\n   * Submits a test case result.\n   * @param params - The parameters for submitting the test case result.\n   * @returns A promise that resolves when the test case result is submitted.\n   */\n  async submitTestCaseResult(params: SubmitTestCaseResultDto): Promise<void> {\n    this.callsInFlight += 1;\n    try {\n      await this.client.post('/api/v1.0/test-result', params);\n    } finally {\n      this.callsInFlight -= 1;\n    }\n  }\n\n  /**\n   * Retrieves the provider session links for the specified test results.\n   * @param resultIds - The IDs of the test results.\n   * @returns A promise that resolves to the response containing the provider session links.\n   */\n  async getProviderSessionLinks(\n    resultIds: number[]\n  ): Promise<AxiosResponse<TestResultProviderInfo[]>> {\n    this.callsInFlight += 1;\n    try {\n      // this filters out falsy values (null, undefined, 0)\n      const validIds: number[] = resultIds.filter(id => id);\n      return await this.client.post<TestResultProviderInfo[]>(\n        '/api/v1.0/test-result/provider-info',\n        validIds\n      );\n    } finally {\n      this.callsInFlight -= 1;\n    }\n  }\n\n  /**\n   * Sends a heartbeat for the specified test run.\n   * @param testRunId - The ID of the test run.\n   * @returns A promise that resolves to the response indicating the heartbeat was sent.\n   */\n  async sendSdkHeartbeat(testRunId: number): Promise<AxiosResponse<void>> {\n    this.callsInFlight += 1;\n    try {\n      // this filters out falsy values (null, undefined, 0)\n      return await this.client.post<void>('/api/v2.0/sdk-heartbeat', {\n        testRunId: testRunId,\n      });\n    } finally {\n      this.callsInFlight -= 1;\n    }\n  }\n\n  /**\n   * Retrieves the email address for the specified email prefix.\n   * @param emailPrefix - The prefix of the email address.\n   * @returns A promise that resolves to the response containing the email address.\n   */\n  async getEmailAddress(\n    emailPrefix: string\n  ): Promise<AxiosResponse<EmailAddressResponse>> {\n    this.callsInFlight += 1;\n    try {\n      // this filters out falsy values (null, undefined, 0)\n      return await this.client.get<EmailAddressResponse>(\n        `/api/v1.0/email/get-address?prefix=${emailPrefix}`\n      );\n    } finally {\n      this.callsInFlight -= 1;\n    }\n  }\n\n  /**\n   * Retrieves the content of the specified email.\n   * @param request - The request parameters for retrieving the email content.\n   * @returns A promise that resolves to the response containing the email content.\n   */\n  async getEmailContent(\n    request: EmailFetchRequest\n  ): Promise<AxiosResponse<Buffer>> {\n    this.callsInFlight += 1;\n    try {\n      // this filters out falsy values (null, undefined, 0)\n      return await this.client.post<Buffer>(\n        '/api/v1.0/email/download-email',\n        request\n      );\n    } finally {\n      this.callsInFlight -= 1;\n    }\n  }\n\n  /**\n   * Uploads an asset for the specified test result.\n   * @param resultId - The ID of the test result.\n   * @param file - The file to upload as an asset.\n   * @param assetName - The name of the asset.\n   * @param providerSessionGuid - The GUID of the provider session.\n   * @param assetType - The type of the asset.\n   * @returns A promise that resolves to the response indicating the asset was uploaded.\n   */\n  async uploadAsset(\n    resultId: number,\n    file: Buffer,\n    assetName: string,\n    providerSessionGuid: string,\n    assetType: AssetType\n  ): Promise<AxiosResponse<void>> {\n    this.callsInFlight += 1;\n\n    try {\n      // this filters out falsy values (null, undefined, 0)\n      return await this.client.postForm<void>(\n        `/api/v1.0/test-result/${resultId}/upload`,\n        {\n          file,\n          assetName,\n          providerSessionGuid,\n          assetType,\n        }\n      );\n    } finally {\n      this.callsInFlight -= 1;\n    }\n  }\n}\n","/**\n * Configuration of the auto-api client\n */\nexport type ClientConfig = {\n  readonly baseUrl: string;\n  readonly apiKey: string;\n};\n\n/**\n * DTO used to create a new Applause test run\n */\nexport interface TestRunCreateDto {\n  // Required: a list of test cases to pre-create\n  tests: string[];\n}\n\n/**\n * DTO modeling the response to a test run creation request\n */\nexport interface TestRunCreateResponseDto {\n  // The ID of the Applause Test Run\n  runId: number;\n}\n\nexport interface AdditionalTestCaseParams {\n  // A collection of provider session guids\n  providerSessionIds?: string[];\n\n  // Optional: TestRail Test Case Id\n  testCaseId?: string;\n\n  // Optional: Applause Test Case Id\n  itwTestCaseId?: string;\n}\n\n/**\n * DTO used to mark the start of a test result\n */\nexport interface CreateTestCaseResultDto extends AdditionalTestCaseParams {\n  // ID of the test run to submit this result to\n  testRunId: number;\n\n  // Name of the Test Case\n  testCaseName: string;\n}\n\n/**\n * DTO response to a test result creation request\n */\nexport interface CreateTestCaseResultResponseDto {\n  testResultId: number;\n}\n\nexport interface AdditionalTestCaseResultParams {\n  // A list of selenium provider session ids to connect to the result\n  providerSessionGuids?: string[];\n\n  // An optional testrail test case id\n  testRailCaseId?: number;\n\n  // An optional applause test case id\n  itwCaseId?: number;\n\n  // The reason a test case failed\n  failureReason?: string;\n}\n\n/**\n * DTO used to submit a status to an in progress test result.\n */\nexport interface SubmitTestCaseResultDto\n  extends AdditionalTestCaseResultParams {\n  // The id of the test result\n  testResultId: number;\n\n  // The ending status of the test.\n  status: TestResultStatus;\n}\n\n/**\n * Enum representing a test result's status\n */\nexport enum TestResultStatus {\n  NOT_RUN = 'NOT_RUN',\n  IN_PROGRESS = 'IN_PROGRESS',\n  PASSED = 'PASSED',\n  FAILED = 'FAILED',\n  SKIPPED = 'SKIPPED',\n  CANCELED = 'CANCELED',\n  ERROR = 'ERROR',\n}\n\n/**\n * DTO representing test result info that is provided at the end of a test run\n */\nexport interface TestResultProviderInfo {\n  testResultId: number;\n  providerUrl: string;\n  providerSessionId: string;\n}\n\n/**\n * DTO representing TestRail settings. The presence of this info signals that test rail reporting is enabled\n */\nexport interface TestRailOptions {\n  projectId: number;\n  suiteId: number;\n  planName: string;\n  runName: string;\n  addAllTestsToPlan?: boolean;\n  overrideTestRailRunUniqueness?: boolean;\n}\n\n/**\n * DTO containing a generated email address for testing\n */\nexport interface EmailAddressResponse {\n  emailAddress: string;\n}\n\n/**\n * DTO used for fetching an email from a given email address\n */\nexport interface EmailFetchRequest {\n  emailAddress: string;\n}\n\nexport enum AssetType {\n  SCREENSHOT = 'SCREENSHOT',\n  FAILURE_SCREENSHOT = 'FAILURE_SCREENSHOT',\n  VIDEO = 'VIDEO',\n  NETWORK_HAR = 'NETWORK_HAR',\n  VITALS_LOG = 'VITALS_LOG',\n  CONSOLE_LOG = 'CONSOLE_LOG',\n  NETWORK_LOG = 'NETWORK_LOG',\n  DEVICE_LOG = 'DEVICE_LOG',\n  SELENIUM_LOG = 'SELENIUM_LOG',\n  SELENIUM_LOG_JSON = 'SELENIUM_LOG_JSON',\n  BROWSER_LOG = 'BROWSER_LOG',\n  FRAMEWORK_LOG = 'FRAMEWORK_LOG',\n  EMAIL = 'EMAIL',\n  PAGE_SOURCE = 'PAGE_SOURCE',\n  CODE_BUNDLE = 'CODE_BUNDLE',\n  RESULTS_ZIP = 'RESULTS_ZIP',\n  SESSION_DETAILS = 'SESSION_DETAILS',\n  DEVICE_DETAILS = 'DEVICE_DETAILS',\n  UNKNOWN = 'UNKNOWN',\n}\n","import { AutoApi } from '../auto-api.ts';\nimport { ParsedMail, simpleParser } from 'mailparser';\n\n/**\n * Represents an email inbox.\n */\nexport class Inbox {\n  /**\n   * Creates an instance of Inbox.\n   * @param emailAddress - The email address associated with the inbox.\n   * @param autoApi - An instance of the AutoApi class.\n   */\n  constructor(\n    public readonly emailAddress: string,\n    private autoApi: AutoApi\n  ) {}\n\n  /**\n   * Retrieves the content of an email from the inbox.\n   * @returns A Promise that resolves to the parsed email content.\n   */\n  async getEmail(): Promise<ParsedMail> {\n    const res = await this.autoApi.getEmailContent({\n      emailAddress: this.emailAddress,\n    });\n    return await simpleParser(res.data);\n  }\n}\n","import winston from 'winston';\nimport { AutoApi } from './auto-api.ts';\nimport { constructDefaultLogger } from '../shared/logging.ts';\n\n/**\n * Represents a service for sending heartbeats during a test run.\n */\nexport class TestRunHeartbeatService {\n  private enabled = false;\n  private nextHeartbeat?: Promise<void>;\n  private readonly logger: winston.Logger;\n\n  /**\n   * Creates an instance of TestRunHeartbeatService.\n   * @param testRunId - The ID of the test run.\n   * @param autoApi - The AutoApi instance used for sending heartbeats.\n   */\n  constructor(\n    readonly testRunId: number,\n    readonly autoApi: AutoApi,\n    logger?: winston.Logger\n  ) {\n    this.logger = logger ?? constructDefaultLogger();\n  }\n\n  /**\n   * Starts sending heartbeats.\n   * @returns A promise that resolves when the heartbeats are started.\n   */\n  async start(): Promise<void> {\n    // End the current heartbeat if it has started\n    await this.end();\n\n    // Set up a new interval\n    this.enabled = true;\n    this.scheduleNextHeartbeat();\n  }\n\n  /**\n   * Checks if the heartbeats are enabled.\n   * @returns True if the heartbeats are enabled, false otherwise.\n   */\n  public isEnabled(): boolean {\n    return this.enabled;\n  }\n\n  private scheduleNextHeartbeat(): void {\n    if (!this.enabled) {\n      return;\n    }\n    this.nextHeartbeat = new Promise(resolve => setTimeout(resolve, 5000)).then(\n      () => this.sendHeartbeat()\n    );\n  }\n\n  private async sendHeartbeat(): Promise<void> {\n    this.logger.debug('Sending heartbeat');\n    await this.autoApi.sendSdkHeartbeat(this.testRunId);\n    this.logger.debug('Heartbeat sent');\n    this.scheduleNextHeartbeat();\n  }\n\n  /**\n   * Ends the heartbeats.\n   * @returns A promise that resolves when the heartbeats are ended.\n   */\n  async end(): Promise<void> {\n    if (this.nextHeartbeat !== undefined) {\n      this.enabled = false;\n      this.logger.debug('Ending Applause SDK Heartbeat');\n      await this.nextHeartbeat;\n      this.logger.debug('Applause SDK Heartbeat Ended Successfully');\n    }\n    this.nextHeartbeat = undefined;\n  }\n}\n","import * as winston from 'winston';\n\nexport const TEST_RAIL_CASE_ID_PREFIX: string = 'TestRail-';\nexport const APPLAUSE_CASE_ID_PREFIX: string = 'Applause-';\n\nexport function parseTestCaseName(\n  testCaseName: string,\n  logger?: winston.Logger\n): ParsedTestCaseName {\n  const matches = testCaseName.match(/(TestRail-\\d+|Applause-\\d+)/g);\n  const testRailCaseIds =\n    matches\n      ?.filter(match => match.startsWith(TEST_RAIL_CASE_ID_PREFIX))\n      .map(match => match.substring(TEST_RAIL_CASE_ID_PREFIX.length)) ?? [];\n  const applauseCaseIds =\n    matches\n      ?.filter(match => match.startsWith(APPLAUSE_CASE_ID_PREFIX))\n      .map(match => match.substring(APPLAUSE_CASE_ID_PREFIX.length)) ?? [];\n\n  if (testRailCaseIds.length > 1) {\n    (logger ?? console).warn(\n      'Multiple TestRail case ids detected in testCase name'\n    );\n  }\n  if (applauseCaseIds.length > 1) {\n    (logger ?? console).warn(\n      'Multiple Applause case ids detected in testCase name'\n    );\n  }\n  return {\n    applauseTestCaseId: applauseCaseIds[0],\n    testRailTestCaseId: testRailCaseIds[0],\n    testCaseName: testCaseName\n      .replace(/(TestRail-\\d+|Applause-\\d+)/g, '')\n      .replace(/\\s+/g, ' ')\n      .trim(),\n  };\n}\n\nexport interface ParsedTestCaseName {\n  testCaseName: string;\n  testRailTestCaseId?: string;\n  applauseTestCaseId?: string;\n}\n","import { writeFileSync } from 'fs';\nimport { AutoApi } from './auto-api.ts';\nimport {\n  AdditionalTestCaseParams,\n  AdditionalTestCaseResultParams,\n  AssetType,\n  TestResultStatus,\n} from './dto.ts';\nimport { TestRunHeartbeatService } from './heartbeat.ts';\nimport { join as pathJoin } from 'path';\nimport { AutoApiConfig } from './auto-api-config.ts';\nimport { parseTestCaseName } from '../shared/test-case.ts';\nimport * as winston from 'winston';\nimport { constructDefaultLogger } from '../shared/logging.ts';\n\n/**\n * Represents an Applause reporter.\n */\nexport class ApplauseReporter {\n  private autoApi: AutoApi;\n  private initializer: RunInitializer;\n  private logger: winston.Logger;\n  private reporter?: Promise<RunReporter>;\n  private runStarted: boolean = false;\n  private runFinished: boolean = false;\n\n  /**\n   * Creates an instance of ApplauseReporter.\n   * @param config - The Applause configuration.\n   */\n  constructor(config: AutoApiConfig, logger?: winston.Logger) {\n    this.logger = logger ?? constructDefaultLogger();\n    this.autoApi = new AutoApi(config, this.logger);\n    this.initializer = new RunInitializer(this.autoApi, this.logger);\n    const runId = process.env['APPLAUSE_RUN_ID'];\n    if (runId !== undefined) {\n      const r = new RunReporter(\n        this.autoApi,\n        parseInt(runId),\n        undefined,\n        this.logger\n      );\n      this.reporter = new Promise(resolve => resolve(r));\n      this.runStarted = true;\n    }\n  }\n\n  /**\n   * Starts the Applause runner.\n   * @param tests - Optional array of test names to run.\n   * @returns A promise that resolves to the test run ID.\n   * @throws Error if a run is already started or finished.\n   */\n  public async runnerStart(tests?: string[]): Promise<number> {\n    if (this.reporter !== undefined) {\n      this.logger.error(\n        'Cannot start a run - run already started or run already finished'\n      );\n      throw new Error(\n        'Cannot start a run - run already started or run already finished'\n      );\n    }\n    this.reporter = this.initializer.initializeRun(tests);\n    const initializedReporter = await this.reporter;\n    this.runStarted = true;\n    process.env['APPLAUSE_RUN_ID'] = initializedReporter.testRunId.toString();\n    return initializedReporter.testRunId;\n  }\n\n  /**\n   * Starts a test case.\n   * @param id - The ID of the test case.\n   * @param testCaseName - The name of the test case.\n   * @param params - Optional additional parameters for the test case.\n   * @returns A promise that resolves to the test case ID.\n   * @throws Error if a run was never initialized.\n   */\n  public async startTestCase(\n    id: string,\n    testCaseName: string,\n    params?: AdditionalTestCaseParams\n  ): Promise<number> {\n    if (this.reporter === undefined) {\n      this.logger.error(\n        'Cannot start a test case for a run that was never initialized'\n      );\n      throw new Error(\n        'Cannot start a test case for a run that was never initialized'\n      );\n    }\n    const reporter = await this.reporter;\n    return reporter.startTestCase(id, testCaseName, params);\n  }\n\n  /**\n   * Submits a test case result.\n   * @param id - The ID of the test case.\n   * @param status - The status of the test case result.\n   * @param params - Optional additional parameters for the test case result.\n   * @returns A promise that resolves to the test case result ID.\n   * @throws Error if a run was never initialized.\n   */\n  public async submitTestCaseResult(\n    id: string,\n    status: TestResultStatus,\n    params?: AdditionalTestCaseResultParams\n  ): Promise<number> {\n    if (this.reporter === undefined) {\n      this.logger.error(\n        'Cannot submit test case result for a run that was never initialized'\n      );\n      throw new Error(\n        'Cannot submit test case result for a run that was never initialized'\n      );\n    }\n    const reporter = await this.reporter;\n    return reporter.submitTestCaseResult(id, status, params);\n  }\n\n  /**\n   * Ends the Applause runner.\n   * @returns A promise that resolves when the runner is ended.\n   * @throws Error if a run was never initialized.\n   */\n  public async runnerEnd(): Promise<void> {\n    if (this.reporter === undefined) {\n      this.logger.error('Cannot end a run that was never initialized');\n      throw new Error('Cannot end a run that was never initialized');\n    }\n    await this.reporter\n      .then(reporter => reporter.runnerEnd())\n      .then(() => (this.runFinished = true));\n  }\n\n  /**\n   * Attaches an asset to a test case.\n   * @param id - The ID of the test case.\n   * @param assetName - The name of the asset.\n   * @param providerSessionGuid - The provider session GUID.\n   * @param assetType - The type of the asset.\n   * @param asset - The asset data as a Buffer.\n   * @returns A promise that resolves when the asset is attached.\n   * @throws Error if a run was never initialized.\n   */\n  public async attachTestCaseAsset(\n    id: string,\n    assetName: string,\n    providerSessionGuid: string,\n    assetType: AssetType,\n    asset: Buffer\n  ): Promise<void> {\n    if (this.reporter === undefined) {\n      this.logger.error(\n        'Cannot attach an asset for a run that was never initialized'\n      );\n      throw new Error(\n        'Cannot attach an asset for a run that was never initialized'\n      );\n    }\n    return await this.reporter.then(reporter =>\n      reporter.attachTestCaseAsset(\n        id,\n        assetName,\n        providerSessionGuid,\n        assetType,\n        asset\n      )\n    );\n  }\n\n  /**\n   * Checks if the Applause runner is synchronized.\n   * @returns True if the runner is not yet started or has ended, and all calls made to the applause API have finished.\n   */\n  public isSynchronized(): boolean {\n    return (\n      (!this.runStarted || (this.runStarted && this.runFinished)) &&\n      this.autoApi.getCallsInFlight == 0\n    );\n  }\n}\n\n/**\n * Represents a Run Initializer.\n */\nexport class RunInitializer {\n  private logger: winston.Logger;\n  constructor(\n    private autoApi: AutoApi,\n    logger?: winston.Logger\n  ) {\n    this.logger = logger ?? constructDefaultLogger();\n  }\n\n  /**\n   * Initializes a test run.\n   * @param tests - An optional array of test names to include in the run.\n   * @returns A promise that resolves to a RunReporter instance.\n   * @throws An error if unable to create the test run.\n   */\n  async initializeRun(tests?: string[]): Promise<RunReporter> {\n    const cleanedTests = tests\n      ?.map(testName => parseTestCaseName(testName, this.logger))\n      .map(parsed => parsed.testCaseName.trim());\n    const testRunCreateResponse = await this.autoApi.startTestRun({\n      tests: cleanedTests ?? [],\n    });\n    if (\n      testRunCreateResponse.status < 200 ||\n      testRunCreateResponse.status > 300\n    ) {\n      this.logger.error(\n        `Failed to create Applause Test Run: received error response with status ${testRunCreateResponse.status}.`\n      );\n      throw new Error('Unable to create test run');\n    }\n    const runId = testRunCreateResponse.data.runId;\n    this.logger.info(`Test Run ${runId} initialized`);\n    const heartbeatService = new TestRunHeartbeatService(\n      runId,\n      this.autoApi,\n      this.logger\n    );\n    await heartbeatService.start();\n    return new RunReporter(this.autoApi, runId, heartbeatService, this.logger);\n  }\n}\n\n/**\n * Handles reporting test results to the Applause API.\n */\nexport class RunReporter {\n  private uidToResultIdMap: Record<string, Promise<number>> = {};\n  private resultSubmissionMap: Record<string, Promise<number>> = {};\n  private logger: winston.Logger;\n\n  /**\n   * Creates a new instance of the Reporter class.\n   * @param autoApi - The AutoApi instance.\n   * @param testRunId - The ID of the test run.\n   * @param heartbeatService - (Optional) The TestRunHeartbeatService instance.\n   */\n  constructor(\n    private autoApi: AutoApi,\n    public readonly testRunId: number,\n    private heartbeatService?: TestRunHeartbeatService,\n    logger?: winston.Logger\n  ) {\n    this.logger = logger ?? constructDefaultLogger();\n  }\n\n  /**\n   * Starts a test case and returns a promise that resolves to the test result ID.\n   *\n   * @param id - The ID of the test case.\n   * @param testCaseName - The name of the test case.\n   * @param params - Additional parameters for the test case.\n   * @returns A promise that resolves to the test result ID.\n   */\n  public startTestCase(\n    id: string,\n    testCaseName: string,\n    params?: AdditionalTestCaseParams\n  ): Promise<number> {\n    if (!testCaseName) {\n      this.logger.error('testCaseName is required');\n      throw new Error('testCaseName is required');\n    }\n    const parsedTestCase = parseTestCaseName(testCaseName, this.logger);\n    const submission = this.autoApi\n      .startTestCase({\n        testCaseName: parsedTestCase.testCaseName,\n        testCaseId: parsedTestCase.testRailTestCaseId,\n        itwTestCaseId: parsedTestCase.applauseTestCaseId,\n\n        testRunId: this.testRunId,\n        // If the additional params provides either test case id, it will override the parsed value we set above\n        ...Object.fromEntries(\n          Object.entries(params || {}).filter(params => params[1] !== undefined)\n        ),\n      })\n      .then(res => {\n        return res.data.testResultId;\n      });\n    this.uidToResultIdMap[id] = submission;\n    return submission;\n  }\n\n  /**\n   * Submits the result of a test case.\n   *\n   * @param id - The ID of the test case.\n   * @param status - The status of the test result.\n   * @param params - Additional parameters for the test result.\n   * @returns A promise that resolves to the result ID.\n   */\n  public submitTestCaseResult(\n    id: string,\n    status: TestResultStatus,\n    params?: AdditionalTestCaseResultParams\n  ): Promise<number> {\n    const submission = this.uidToResultIdMap[id]?.then(resultId =>\n      this.autoApi\n        .submitTestCaseResult({\n          status: status,\n          testResultId: resultId,\n          ...params,\n        })\n        .then(() => resultId)\n    );\n    this.resultSubmissionMap[id] = submission;\n    return submission;\n  }\n\n  /**\n   * Attaches a test case asset to a result.\n   *\n   * @param id - The ID of the test case.\n   * @param assetName - The name of the asset.\n   * @param providerSessionGuid - The provider session GUID.\n   * @param assetType - The type of the asset.\n   * @param asset - The asset to attach.\n   * @returns A promise that resolves when the asset is attached.\n   */\n  public async attachTestCaseAsset(\n    id: string,\n    assetName: string,\n    providerSessionGuid: string,\n    assetType: AssetType,\n    asset: Buffer\n  ): Promise<void> {\n    await this.uidToResultIdMap[id]?.then(resultId =>\n      this.autoApi.uploadAsset(\n        resultId,\n        asset,\n        assetName,\n        providerSessionGuid,\n        assetType\n      )\n    );\n  }\n\n  /**\n   * Ends the test runner and performs necessary cleanup tasks.\n   * @returns A promise that resolves when the runner has ended.\n   */\n  public async runnerEnd(): Promise<void> {\n    // Wait for all results to be created\n    const resultIds =\n      (await Promise.all(Object.values(this.uidToResultIdMap))) ?? [];\n\n    // Wait for the results to be submitted\n    void (await Promise.all(Object.values(this.resultSubmissionMap)));\n\n    // Wait the heartbeat to be ended\n    void (await this.heartbeatService?.end());\n    void (await this.autoApi.endTestRun(this.testRunId));\n\n    // Fetch the provider session asset links and save them off to a file\n    const resp = await this.autoApi.getProviderSessionLinks(resultIds);\n    const jsonArray = resp.data ?? [];\n    if (jsonArray.length > 0) {\n      this.logger.info(JSON.stringify(jsonArray));\n      // this is the wdio.conf outputDir\n      const outputPath = '.';\n      writeFileSync(\n        pathJoin(outputPath, 'providerUrls.txt'),\n        JSON.stringify(jsonArray, null, 1)\n      );\n    }\n  }\n}\n","export interface TestRunAutoResultDto {\n  testCycleId: number;\n  status: TestRunAutoResultStatus;\n  failureReason?: string;\n  sessionDetailsJson?: SessionDetails;\n  startTime?: Date;\n  endTime?: Date;\n}\n\nexport enum TestRunAutoResultStatus {\n  PASSED = 'PASSED',\n  FAILED = 'FAILED',\n  SKIPPED = 'SKIPPED',\n  CANCELED = 'CANCELED',\n  ERROR = 'ERROR',\n}\n\nexport interface SessionDetails {\n  value: {\n    deviceName?: string;\n    orientation?: string;\n    platformName?: string;\n    platformVersion?: string;\n    browserName?: string;\n    browserVersion?: string;\n  };\n}\n","import Validator from 'validator';\nconst validator = Validator.default;\n\nexport interface PublicApiConfig {\n  readonly publicApiBaseUrl: string;\n  readonly apiKey: string;\n  readonly productId: number;\n  readonly applauseTestCycleId?: number;\n}\n\nexport const DEFAULT_URL = 'https://api.applause.com/';\n\nexport const DEFAULT_PUBLIC_API_PROPERTIES: Partial<PublicApiConfig> = {\n  publicApiBaseUrl: DEFAULT_URL,\n};\n\nexport function isPublicApiConfigComplete(\n  config: Partial<PublicApiConfig>\n): boolean {\n  return (\n    config.publicApiBaseUrl !== undefined &&\n    config.apiKey !== undefined &&\n    config.productId !== undefined\n  );\n}\n\nexport function validatePartialPublicApiConfig(\n  config: Partial<PublicApiConfig>\n) {\n  if (\n    config.productId !== undefined &&\n    (!Number.isInteger(config.productId) || config.productId <= 0)\n  ) {\n    throw new Error(\n      `productId must be a positive integer, was: '${config.productId}'`\n    );\n  }\n}\n\nexport function validatePublicApiConfig(config: PublicApiConfig) {\n  if (!Number.isInteger(config.productId) || config.productId <= 0) {\n    throw new Error(\n      `productId must be a positive integer, was: '${config.productId}'`\n    );\n  }\n  if (\n    !validator.isURL(config.publicApiBaseUrl, {\n      protocols: ['http', 'https'],\n      require_tld: false, // allow localhost\n      allow_query_components: false,\n      disallow_auth: true,\n      allow_fragments: false,\n      allow_protocol_relative_urls: false,\n      allow_trailing_dot: false,\n      require_host: true,\n      require_protocol: true,\n    })\n  ) {\n    throw new Error(\n      `publicApiBaseUrl is not valid HTTP/HTTPS URL, was: ${config.publicApiBaseUrl}`\n    );\n  }\n\n  if (validator.isEmpty(config.apiKey)) {\n    throw new Error('apiKey is an empty string!');\n  }\n}\n","/**\n * Represents the configuration options for the Applause Reporter.\n */\nimport { existsSync, readFileSync } from 'fs';\nimport path from 'path';\n\nimport {\n  AutoApiConfig,\n  DEFAULT_AUTO_API_PROPERTIES,\n  isAutoApiConfigComplete,\n  validateAutoApiConfig,\n} from '../auto-api/auto-api-config.ts';\nimport {\n  DEFAULT_PUBLIC_API_PROPERTIES,\n  isPublicApiConfigComplete,\n  PublicApiConfig,\n  validatePublicApiConfig,\n} from '../public-api/public-api-config.ts';\n\nexport type ApplauseConfig = AutoApiConfig & PublicApiConfig;\n\n/**\n * Represents the properties for loading the configuration.\n */\nexport interface ConfigLoadProperties {\n  configFile?: string;\n  properties?: Partial<ApplauseConfig>;\n}\n\n/**\n * Loads the configuration for the Applause Reporter.\n * @param loadOptions - The options for loading the configuration.\n * @returns The loaded Applause configuration.\n * @throws Error if the configuration is not complete or invalid.\n */\nexport function loadConfig(loadOptions?: ConfigLoadProperties): ApplauseConfig {\n  // Setup the initial config with any default properties\n  let config: Partial<ApplauseConfig> = {\n    ...DEFAULT_PUBLIC_API_PROPERTIES,\n    ...DEFAULT_AUTO_API_PROPERTIES,\n  };\n\n  // Load properties from the provided config file\n  if (loadOptions !== undefined && loadOptions.configFile !== undefined) {\n    config = overrideConfig(\n      config,\n      loadConfigFromFile(path.join(process.cwd(), loadOptions.configFile))\n    );\n  } else {\n    // Override from the default config file\n    config = overrideConfig(config, loadConfigFromFile());\n  }\n\n  // Then load in the file override properties\n  if (loadOptions !== undefined && loadOptions.properties !== undefined) {\n    config = overrideConfig(config, loadOptions.properties);\n  }\n\n  if (!isComplete(config)) {\n    throw new Error('Config is not complete');\n  }\n\n  // We know that the config is complete, so we can cast\n  const finalConfig = config as ApplauseConfig;\n\n  validateConfig(finalConfig);\n\n  return finalConfig;\n}\n\n/**\n * Overrides the configuration with the provided overrides.\n * @param config - The base configuration.\n * @param overrides - The overrides to apply.\n * @returns The overridden configuration.\n */\nexport function overrideConfig(\n  config: Partial<ApplauseConfig>,\n  overrides?: Partial<ApplauseConfig>\n): Partial<ApplauseConfig> {\n  return Object.assign(\n    {},\n    config,\n    Object.fromEntries(\n      Object.entries(overrides ?? {}).filter(params => params[1] !== undefined)\n    )\n  );\n}\n\n/**\n * Checks if the configuration is complete.\n * @param config - The configuration to check.\n * @returns True if the configuration is complete, false otherwise.\n */\nexport function isComplete(config: Partial<ApplauseConfig>): boolean {\n  return isAutoApiConfigComplete(config) && isPublicApiConfigComplete(config);\n}\n\n/**\n * Loads the configuration from the specified file.\n * @param configFile - The path to the configuration file.\n * @returns The loaded configuration from the file.\n */\nexport function loadConfigFromFile(\n  configFile?: string\n): Partial<ApplauseConfig> {\n  const configFilePath = configFile ?? `${process.cwd()}/applause.json`;\n  if (!existsSync(configFilePath)) {\n    return {};\n  }\n  const fileContents = readFileSync(configFilePath, 'utf8');\n  return JSON.parse(fileContents) as Partial<ApplauseConfig>;\n}\n\n/**\n * Validates the configuration.\n * @param config - The configuration to validate.\n * @throws Error if the configuration is invalid.\n */\nexport function validateConfig(config: ApplauseConfig) {\n  validateAutoApiConfig(config);\n  validatePublicApiConfig(config);\n}\n\n/**\n * Validates a partial configuration.\n * @param config - The partial configuration to validate.\n * @throws Error if the partial configuration is invalid.\n */\nexport function validatePartialConfig(config: Partial<ApplauseConfig>) {\n  if (\n    config.productId !== undefined &&\n    (!Number.isInteger(config.productId) || config.productId <= 0)\n  ) {\n    throw new Error(\n      `productId must be a positive integer, was: '${config.productId}'`\n    );\n  }\n}\n","import { AutoApi } from './auto-api.ts';\nimport { Inbox } from './email/inbox.ts';\n\n/**\n * Helper class for managing email functionality.\n */\nexport class EmailHelper {\n  constructor(private autoApi: AutoApi) {}\n\n  /**\n   * Retrieves the inbox for the specified email prefix.\n   *\n   * @param emailPrefix - The prefix used to generate the email address.\n   * @returns A Promise that resolves to an Inbox object.\n   */\n  async getInbox(emailPrefix: string): Promise<Inbox> {\n    const generatedAddress: string = (\n      await this.autoApi.getEmailAddress(emailPrefix)\n    ).data.emailAddress;\n    return new Inbox(generatedAddress, this.autoApi);\n  }\n}\n\nexport * from './email/attachment.ts';\nexport * from './email/inbox.ts';\n","import axios, { AxiosError, AxiosInstance, AxiosResponse } from 'axios';\nimport { TestRunAutoResultDto } from './dto.ts';\nimport {\n  PublicApiConfig,\n  validatePublicApiConfig,\n} from './public-api-config.ts';\nimport * as winston from 'winston';\nimport { constructDefaultLogger } from '../shared/logging.ts';\n\nexport class PublicApi {\n  private readonly client: AxiosInstance;\n\n  private callsInFlight: number;\n  private logger: winston.Logger;\n  /**\n   * tracks number of HTTP calls in progress, used by reporters that want to know when our async work is finished\n   */\n  public get getCallsInFlight(): number {\n    return this.callsInFlight;\n  }\n\n  constructor(\n    readonly options: PublicApiConfig,\n    logger?: winston.Logger\n  ) {\n    this.callsInFlight = 0;\n    this.logger = logger ?? constructDefaultLogger();\n    validatePublicApiConfig(options);\n    this.client = axios.create({\n      baseURL: options.publicApiBaseUrl,\n      timeout: 10000,\n      headers: {\n        'X-Api-Key': options.apiKey,\n        'Context-Type': 'application/json',\n      },\n      responseType: 'json',\n    });\n    this.client.interceptors.response.use(\n      function (response: AxiosResponse<unknown, unknown>) {\n        return response;\n      },\n      (error: AxiosError) => {\n        // log and rethrow\n        const errText =\n           \n          error.response?.data !== undefined\n            ? JSON.stringify(error.response.data)\n            : `error-code [${error.response?.status}] with error [${error.response?.statusText}]`;\n        this.logger.error(`Public-Api returned ${errText}`);\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  async submitResult(\n    testCaseId: number,\n    info: TestRunAutoResultDto\n  ): Promise<AxiosResponse<void>> {\n    this.callsInFlight += 1;\n    try {\n      return await this.client.post<void>(\n        `v2/test-case-results/${testCaseId}/submit`,\n        info\n      );\n    } finally {\n      this.callsInFlight -= 1;\n    }\n  }\n}\n"],"names":["validator","Validator","default","DEFAULT_AUTO_API_PROPERTIES","autoApiBaseUrl","validateAutoApiConfig","config","Number","isInteger","productId","Error","isURL","protocols","require_tld","allow_query_components","disallow_auth","allow_fragments","allow_protocol_relative_urls","allow_trailing_dot","require_host","require_protocol","isEmpty","apiKey","MESSAGE","Symbol","for","WINSTON_DEFAULT_LOG_FORMAT","winston","format","printf","level","message","label","timestamp","constructDefaultLogger","createLogger","combine","splat","transports","File","filename","ApplauseTransport","Console","colorize","LoggingContainer","logs","getLogs","this","drainLogs","clearLogs","addLog","log","push","APPLAUSE_LOG_RECORDS","TransportStream","constructor","opts","super","info","callback","setImmediate","emit","transform","AutoApi","options","client","logger","callsInFlight","getCallsInFlight","axios","create","baseURL","timeout","headers","responseType","interceptors","response","use","error","errText","undefined","data","JSON","stringify","status","statusText","Promise","reject","startTestRun","post","sdkVersion","itwTestCycleId","applauseTestCycleId","testRailReportingEnabled","testRailOptions","addAllTestsToPlan","testRailProjectId","projectId","testRailSuiteId","suiteId","testRailPlanName","planName","testRailRunName","runName","overrideTestRailRunNameUniqueness","overrideTestRailRunUniqueness","endTestRun","testRunId","delete","startTestCase","params","submitTestCaseResult","getProviderSessionLinks","resultIds","validIds","filter","id","sendSdkHeartbeat","getEmailAddress","emailPrefix","get","getEmailContent","request","uploadAsset","resultId","file","assetName","providerSessionGuid","assetType","postForm","TestResultStatus","AssetType","Inbox","emailAddress","autoApi","getEmail","res","simpleParser","TestRunHeartbeatService","enabled","nextHeartbeat","start","end","scheduleNextHeartbeat","isEnabled","resolve","setTimeout","then","sendHeartbeat","debug","TEST_RAIL_CASE_ID_PREFIX","APPLAUSE_CASE_ID_PREFIX","parseTestCaseName","testCaseName","matches","match","testRailCaseIds","startsWith","map","substring","applauseCaseIds","length","console","warn","applauseTestCaseId","testRailTestCaseId","replace","trim","RunInitializer","initializeRun","tests","cleanedTests","testName","parsed","testRunCreateResponse","runId","heartbeatService","RunReporter","uidToResultIdMap","resultSubmissionMap","parsedTestCase","submission","testCaseId","itwTestCaseId","Object","fromEntries","entries","testResultId","attachTestCaseAsset","asset","runnerEnd","all","values","jsonArray","outputPath","writeFileSync","pathJoin","TestRunAutoResultStatus","DEFAULT_PUBLIC_API_PROPERTIES","publicApiBaseUrl","validatePublicApiConfig","overrideConfig","overrides","assign","isComplete","isAutoApiConfigComplete","isPublicApiConfigComplete","loadConfigFromFile","configFile","configFilePath","process","cwd","existsSync","fileContents","readFileSync","parse","validateConfig","initializer","reporter","runStarted","runFinished","env","r","parseInt","runnerStart","initializedReporter","toString","isSynchronized","getInbox","generatedAddress","submitResult","loadOptions","path","join","properties","finalConfig"],"mappings":"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"}